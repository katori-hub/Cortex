// Tag.swift
// Cortex â€” Personal Knowledge Agent
//
// GRDB records for `tags` and `item_tags` tables.
// Tags are both auto-generated (from Gemini extraction) and manual (user-added).

import Foundation
import GRDB

// MARK: - Tag

struct Tag: Identifiable, Equatable {
    var id: Int64?
    var name: String
    var autoGenerated: Bool

    init(name: String, autoGenerated: Bool = true) {
        self.name = name.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        self.autoGenerated = autoGenerated
    }
}

extension Tag: @unchecked Sendable {}

extension Tag: FetchableRecord, MutablePersistableRecord {

    static var databaseTableName: String { "tags" }

    nonisolated init(row: Row) {
        id = row["id"]
        name = row["name"]
        autoGenerated = row["auto_generated"]
    }

    nonisolated func encode(to container: inout PersistenceContainer) {
        container["id"] = id
        container["name"] = name
        container["auto_generated"] = autoGenerated
    }

    nonisolated mutating func didInsert(_ inserted: InsertionSuccess) {
        id = inserted.rowID
    }
}

// MARK: - ItemTag (join record)

struct ItemTag: Codable, FetchableRecord, PersistableRecord, Sendable {
    let itemId: Int64
    let tagId: Int64

    static var databaseTableName: String { "item_tags" }

    enum CodingKeys: String, CodingKey {
        case itemId = "item_id"
        case tagId  = "tag_id"
    }
}

// MARK: - Tag Database Helpers

extension Tag {

    /// Find or create a tag by name. Returns the saved tag with its id.
    @discardableResult
    static func findOrCreate(name: String, autoGenerated: Bool = true, db: Database) throws -> Tag {
        let normalized = name.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)
        if let existing = try Tag.filter(Column("name") == normalized).fetchOne(db) {
            return existing
        }
        var tag = Tag(name: normalized, autoGenerated: autoGenerated)
        try tag.insert(db)
        return tag
    }

    /// Apply a list of tag names to an item. Creates tags that don't exist.
    static func applyTags(_ names: [String], toItemId itemId: Int64, db: Database) throws {
        for name in names {
            let tag = try findOrCreate(name: name, autoGenerated: true, db: db)
            guard let tagId = tag.id else { continue }
            let join = ItemTag(itemId: itemId, tagId: tagId)
            try join.insert(db, onConflict: .ignore)
        }
    }

    /// Fetch all tags for a given item.
    static func tags(forItemId itemId: Int64, db: Database) throws -> [Tag] {
        try Tag
            .joining(required: Tag.hasMany(ItemTag.self, using: ForeignKey(["tag_id"])))
            .filter(sql: "item_tags.item_id = ?", arguments: [itemId])
            .fetchAll(db)
    }
}

